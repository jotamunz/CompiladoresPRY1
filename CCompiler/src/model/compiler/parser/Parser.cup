package model.compiler.parser;

import java_cup.runtime.Symbol;

parser code
{:
    public void syntax_error(Symbol cur_token){
	System.err.println("Syntax error at line: " + (cur_token.right+1) + " at column: " + (cur_token.left+1) + " on: " + cur_token.value);
    }
:};

terminal     
    KEY_AUTO,    
    KEY_BREAK,    
    KEY_CASE,  
    KEY_CHAR,
    KEY_CONST,            
    KEY_CONT,        
    KEY_DEF,        
    KEY_DO,        
    KEY_DOUBLE,        
    KEY_ELSE,        
    KEY_ENUM,         
    KEY_EXT,         
    KEY_FLOAT,         
    KEY_FOR,         
    KEY_GOTO,         
    KEY_IF,         
    KEY_INT,         
    KEY_LONG,         
    KEY_REG,         
    KEY_RET,         
    KEY_SHORT,         
    KEY_SIG,         
    KEY_SIZEOF,         
    KEY_STATIC,         
    KEY_STRUCT,         
    KEY_SWITCH,         
    KEY_TYPEDEF,         
    KEY_UNION,         
    KEY_UNSIG,         
    KEY_VOID,         
    KEY_VOL,         
    KEY_WHILE,         
    KEY_READ,         
    KEY_WRITE,         
    ID,         
    FLOAT,             
    INT,             
    CHAR,             
    STRING,             
    OP_COMA,             
    OP_SEMICOL,             
    OP_QUEST,             
    OP_ASSIGN,             
    OP_PAR_OPEN,             
    OP_PAR_CLOSE,             
    OP_BRACK_OPEN,             
    OP_BRACK_CLOSE,             
    OP_BRACE_OPEN,            
    OP_BRACE_CLOSE,             
    OP_COLON,             
    OP_DOT,             
    OP_ARROW,             
    OP_INC,             
    OP_DEC,             
    OP_ADD,             
    OP_SUB,             
    OP_MULT,             
    OP_DIV,             
    OP_MOD,             
    OP_ADD_ASS,             
    OP_SUB_ASS,             
    OP_MULT_ASS,             
    OP_DIV_ASS,             
    OP_MOD_ASS,             
    OP_EQUAL,             
    OP_GRE_EQ,             
    OP_GREATER,             
    OP_LESS,             
    OP_LESS_EQ,             
    OP_NOT_EQ,             
    OP_OR,             
    OP_AND,             
    OP_NOT,             
    OP_BITAND,             
    OP_BITOR,             
    OP_BITAND_ASS,             
    OP_BITOR_ASS,             
    OP_RSHIFT,     
    OP_LSHIFT,             
    OP_BITOREXC,             
    OP_BITOREXC_ASS,             
    OP_BITCOMPL,             
    OP_RSHIFT_ASS,             
    OP_LSHIFT_ASS,             
    LEX_ERROR 
;

non terminal
    innit,
    key_types,
    expression_statement,
    declaration,
    expression,
    arithmetic_operator,
    logic_operator,
    operand,
    assignment_expression,
    assignment_operator,
    postfix_operator,
    unary_operator,
    if_statement,
    else_statement,
    block_statement,
    for_statement,
    while_statement,
    switch_statement,
    case_blocks,
    case,
    default
;

precedence left OP_OR;
precedence left OP_AND;
precedence left OP_EQUAL, OP_NOT_EQ;
precedence left OP_GRE_EQ, OP_GREATER, OP_LESS, OP_LESS_EQ;
precedence left OP_ADD, OP_SUB;
precedence left OP_MULT, OP_DIV, OP_MOD;
precedence right OP_NOT, OP_ADD, OP_SUB, OP_DEC, OP_INC;
precedence left OP_INC, OP_DEC;

start with innit;

key_types ::=
    KEY_INT
    | KEY_VOID
    | KEY_CHAR
    | KEY_LONG
    | KEY_SHORT
    | KEY_FLOAT
;  

innit ::=
    key_types ID OP_PAR_OPEN OP_PAR_CLOSE OP_BRACE_OPEN block_statement OP_BRACE_CLOSE
    | error 
;


block_statement ::=
    expression_statement OP_SEMICOL block_statement
    | if_statement block_statement
    | for_statement block_statement
    | while_statement block_statement
    | switch_statement block_statement
    |
;

expression_statement ::=
      declaration
    | expression
    | assignment_expression 
    | KEY_BREAK
    | KEY_CONT
;

declaration ::=
    key_types ID OP_ASSIGN expression
;

expression ::=
    expression arithmetic_operator expression
    | expression logic_operator expression
    | OP_PAR_OPEN expression OP_PAR_CLOSE
    | ID postfix_operator 
    | postfix_operator ID
    | unary_operator expression
    | operand
;

operand ::=
    ID
    | INT
    | CHAR
    | STRING
;

arithmetic_operator ::=
    OP_ADD             
    | OP_SUB             
    | OP_MULT             
    | OP_DIV             
    | OP_MOD
;

logic_operator ::=
     OP_EQUAL
    | OP_GRE_EQ
    | OP_GREATER
    | OP_LESS
    | OP_LESS_EQ
    | OP_NOT_EQ 
;

postfix_operator ::=
    OP_INC
    | OP_DEC
;

unary_operator ::=
    OP_NOT
    | OP_ADD
    | OP_SUB
;

assignment_expression ::=
    ID assignment_operator expression
;

assignment_operator ::=
    OP_ADD_ASS             
    | OP_SUB_ASS             
    | OP_MULT_ASS             
    | OP_DIV_ASS             
    | OP_MOD_ASS
    | OP_ASSIGN
;


//Breaks y Continue en estructuras for,while y switch
//Invertir Columnas y Filas 


if_statement ::=
    KEY_IF OP_PAR_OPEN expression OP_PAR_CLOSE OP_BRACE_OPEN block_statement OP_BRACE_CLOSE else_statement
;


else_statement ::= 
    KEY_ELSE OP_BRACE_OPEN block_statement OP_BRACE_CLOSE
    |
;


for_statement ::= 
    KEY_FOR OP_PAR_OPEN expression_statement OP_SEMICOL expression_statement OP_SEMICOL expression_statement OP_PAR_CLOSE 
        OP_BRACE_OPEN block_statement OP_BRACE_CLOSE  
;


while_statement ::= 
    KEY_WHILE OP_PAR_OPEN expression_statement OP_PAR_CLOSE 
        OP_BRACE_OPEN block_statement OP_BRACE_CLOSE  
;


switch_statement ::=
    KEY_SWITCH OP_PAR_OPEN ID OP_PAR_CLOSE
        OP_BRACE_OPEN case_blocks OP_BRACE_CLOSE  
;


case_blocks ::=
    case case_blocks
    | default 
    | 
;

case ::=
    KEY_CASE INT OP_COLON block_statement
;

default ::=
    KEY_DEF OP_COLON block_statement
;